<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <title>Ukraine War Updates</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #map { cursor: grab; }
    .leaflet-dragging #map { cursor: grabbing; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    // === Init map ===
    const map = L.map('map', {
      center: [48.6, 36.5],
      zoom: 7,
      zoomControl: true,
      scrollWheelZoom: true,
      wheelDebounceTime: 20,
      wheelPxPerZoomLevel: 120,
      inertia: true
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // === Panes to avoid blocking mouse ===
    map.createPane('frontPane');     map.getPane('frontPane').style.zIndex = 410;
    map.createPane('advPane');       map.getPane('advPane').style.zIndex   = 405;
    map.createPane('pointsPane');    map.getPane('pointsPane').style.zIndex= 415;
    map.createPane('updatesPane');   map.getPane('updatesPane').style.zIndex=420;

    ['frontPane','advPane','pointsPane','updatesPane'].forEach(p=>{
      map.getPane(p).style.pointerEvents = 'none';
    });

    // === Layers ===
    const frontLayer = L.geoJSON(null, {
      pane: 'frontPane',
      interactive: false,
      bubblingMouseEvents: false,
      style: { color:'#000', weight:4, opacity:0.95, smoothFactor:1 }
    });

    const advancesLayer = L.geoJSON(null, {
      pane: 'advPane',
      interactive: false,
      bubblingMouseEvents: false,
      style: { color:'#000', weight:1, opacity:0.35, smoothFactor:1.2 }
    });

    const pointsLayer = L.geoJSON(null, {
      pane: 'pointsPane',
      interactive: false,
      bubblingMouseEvents: false,
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: 3, color:'#2b6cb0', fillColor:'#2b6cb0', fillOpacity:0.85, weight:0.5
      })
    });

    const updatesLayer = L.layerGroup([], { pane:'updatesPane' });

    // === Load updates.json (flags) ===
    const icons = {
      ru: L.icon({ iconUrl:'ru.png', iconSize:[24,18] }),
      ua: L.icon({ iconUrl:'ua.png', iconSize:[24,18] }),
      nu: L.icon({ iconUrl:'nu.png', iconSize:[24,18] })
    };

    fetch('updates.json').then(r=>r.json()).then(data=>{
      data.forEach(it=>{
        const m = L.marker([it.lat, it.lng], {
          icon: icons[it.side] || icons.nu, pane:'updatesPane'
        }).bindPopup(`<b>${it.title}</b><br>${it.date}<br>${it.summary||''}`);
        updatesLayer.addLayer(m);
      });
    });

    // === Load points (advances1.json) — default OFF to reduce clutter ===
    fetch('advances1.json').then(r=>r.json()).then(geo=> pointsLayer.addData(geo));

    // === Load lines (advances2.json) ONCE, split: longest = front line; others = advances ===
    function haversine(a, b){
      const toRad = d => d*Math.PI/180;
      const R = 6371e3;
      const φ1 = toRad(a[1]), φ2 = toRad(b[1]);
      const dφ = toRad(b[1]-a[1]), dλ = toRad(b[0]-a[0]);
      const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }
    function lineLength(coords){
      let L = 0;
      for(let i=1;i<coords.length;i++) L += haversine(coords[i-1], coords[i]);
      return L;
    }

    fetch('advances2.json').then(r=>r.json()).then(geo=>{
      // collect all LineStrings
      const feats = (geo.features || []).filter(f=>f.geometry && f.geometry.type==='LineString');
      if(!feats.length){
        console.warn('No LineString features in advances2.json');
        return;
      }
      // find longest line as "front"
      let maxLen = -1, maxIdx = -1;
      feats.forEach((f, i)=>{
        const L = lineLength(f.geometry.coordinates);
        if(L > maxLen){ maxLen = L; maxIdx = i; }
      });

      const front = feats[maxIdx];
      const others = feats.filter((_,i)=> i!==maxIdx);

      frontLayer.addData(front).addTo(map);
      advancesLayer.addData(others).addTo(map);

      // fit bounds to front line for a good initial view
      try { map.fitBounds(L.geoJSON(front).getBounds(), { padding:[20,20] }); } catch(e){}
    });

    // === Layer control ===
    const overlays = {
      'קו חזית': frontLayer,
      'קווי התקדמות': advancesLayer,
      'נקודות': pointsLayer,
      'עדכונים': updatesLayer
    };
    L.control.layers(null, overlays, { collapsed:false }).addTo(map);

    // default: show front & advances & updates; leave points OFF to keep המפה נקייה
    updatesLayer.addTo(map);
    // pointsLayer intentionally NOT added by default

  </script>
</body>
</html>
